# 링크드 리스트 문제

## 문제 1: 링크드 리스트 뒤집기 (Easy)
**시간 제한**: 20분

단일 링크드 리스트를 뒤집으세요.

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_linked_list(head):
    """
    예시:
    Input: [1, 2, 3, 4, 5]
    Output: [5, 4, 3, 2, 1]
    
    Input: [1, 2]
    Output: [2, 1]
    
    Input: []
    Output: []
    """
    pass
```

## 문제 2: 두 정렬된 리스트 합치기 (Easy)
**시간 제한**: 25분

두 개의 정렬된 링크드 리스트를 하나의 정렬된 리스트로 합치세요.

```python
def merge_two_sorted_lists(list1, list2):
    """
    예시:
    Input: list1 = [1, 2, 4], list2 = [1, 3, 4]
    Output: [1, 1, 2, 3, 4, 4]
    
    Input: list1 = [], list2 = []
    Output: []
    
    Input: list1 = [], list2 = [0]
    Output: [0]
    """
    pass
```

## 문제 3: 사이클 탐지 (Medium)
**시간 제한**: 30분

링크드 리스트에 사이클이 있는지 확인하세요.

```python
def has_cycle(head):
    """
    예시:
    Input: [3, 2, 0, -4] (마지막 노드가 인덱스 1을 가리킴)
    Output: True
    
    Input: [1, 2] (마지막 노드가 인덱스 0을 가리킴)
    Output: True
    
    Input: [1]
    Output: False
    
    플로이드의 토끼와 거북이 알고리즘 사용해보세요!
    """
    pass
```

## 문제 4: 중간 노드 찾기 (Medium)
**시간 제한**: 20분

링크드 리스트의 중간 노드를 찾으세요. 노드가 짝수 개면 두 번째 중간 노드를 반환하세요.

```python
def find_middle_node(head):
    """
    예시:
    Input: [1, 2, 3, 4, 5]
    Output: 노드 3부터 시작하는 리스트
    
    Input: [1, 2, 3, 4, 5, 6]
    Output: 노드 4부터 시작하는 리스트
    
    Input: [1]
    Output: 노드 1
    """
    pass
```

## 문제 5: 링크드 리스트를 이용한 덧셈 (Hard)
**시간 제한**: 35분

두 숫자가 링크드 리스트로 표현되어 있을 때, 두 수를 더하세요. 각 노드는 한 자리 숫자를 담고 있고, 역순으로 저장되어 있습니다.

```python
def add_two_numbers(l1, l2):
    """
    예시:
    Input: l1 = [2, 4, 3], l2 = [5, 6, 4]
    Output: [7, 0, 8]
    설명: 342 + 465 = 807
    
    Input: l1 = [0], l2 = [0]
    Output: [0]
    
    Input: l1 = [9, 9, 9, 9, 9, 9, 9], l2 = [9, 9, 9, 9]
    Output: [8, 9, 9, 9, 0, 0, 0, 1]
    설명: 9999999 + 9999 = 10009998
    
    주의: 자리 올림(carry) 처리해야 합니다!
    """
    pass
```

## 💡 백엔드 개발자를 위한 학습 포인트
- **링크드 리스트**: 메모리 효율적인 동적 데이터 구조
- **투 포인터**: 시간복잡도 최적화 기법
- **사이클 탐지**: 무한루프 방지, 메모리 누수 탐지
- **재귀와 반복**: 스택 오버플로우 vs 메모리 효율성

## 🔧 실제 백엔드 활용 사례
- **데이터베이스**: B+ Tree 구조의 이해
- **가비지 컬렉션**: 사이클 참조 탐지
- **웹 크롤러**: 무한 루프 방지
- **캐시 구현**: LRU 캐시의 내부 구조
- **메시지 큐**: 큐 내부 구현에 링크드 리스트 활용

## ⚡ 최적화 팁
- 공간복잡도 O(1)로 해결해보기
- 재귀 대신 반복문으로 스택 오버플로우 방지
- 엣지 케이스 처리 (null, 빈 리스트)
- 투 포인터로 한 번의 순회로 문제 해결